package org.apache.spark.sql.catalyst.expressions;
/**
 * User-defined function.
 * param:  function  The user defined scala function to run.
 *                  Note that if you use primitive parameters, you are not able to check if it is
 *                  null or not, and the UDF will return null for you if the primitive input is
 *                  null. Use boxed type or {@link Option} if you wanna do the null-handling yourself.
 * param:  dataType  Return type of function.
 * param:  children  The input expressions of this UDF.
 * param:  inputTypes  The expected input types of this UDF.
 */
public  class ScalaUDF extends org.apache.spark.sql.catalyst.expressions.Expression implements org.apache.spark.sql.catalyst.expressions.ImplicitCastInputTypes, scala.Product, scala.Serializable {
  public  java.lang.Object function () { throw new RuntimeException(); }
  public  org.apache.spark.sql.types.DataType dataType () { throw new RuntimeException(); }
  public  scala.collection.Seq<org.apache.spark.sql.catalyst.expressions.Expression> children () { throw new RuntimeException(); }
  public  scala.collection.Seq<org.apache.spark.sql.types.DataType> inputTypes () { throw new RuntimeException(); }
  // not preceding
  public   ScalaUDF (java.lang.Object function, org.apache.spark.sql.types.DataType dataType, scala.collection.Seq<org.apache.spark.sql.catalyst.expressions.Expression> children, scala.collection.Seq<org.apache.spark.sql.types.DataType> inputTypes) { throw new RuntimeException(); }
  public  boolean nullable () { throw new RuntimeException(); }
  public  java.lang.String toString () { throw new RuntimeException(); }
  /** This method has been generated by this script
   * <p>
   (1 to 22).map { x =&gt;
   val anys = (1 to x).map(x =&gt; "Any").reduce(_ + ", " + _)
   val childs = (0 to x - 1).map(x =&gt; s"val child$x = children($x)").reduce(_ + "\n  " + _)
   val converters = (0 to x - 1).map(x =&gt; s"lazy val converter$x = CatalystTypeConverters.createToScalaConverter(child$x.dataType)").reduce(_ + "\n  " + _)
   val evals = (0 to x - 1).map(x =&gt; s"converter$x(child$x.eval(input))").reduce(_ + ",\n      " + _)
   * <p>
   s"""case $x =&gt;
   val func = function.asInstanceOf[($anys) =&gt; Any]
   $childs
   $converters
   (input: InternalRow) =&gt; {
   func(
   $evals)
   }
   """
   }.foreach(println)
   * <p>
   * @return (undocumented)
   */
  public  java.lang.Object userDefinedFunc () { throw new RuntimeException(); }
  public  scala.collection.Seq<org.apache.spark.sql.catalyst.expressions.Expression> getChildren () { throw new RuntimeException(); }
  private  java.lang.String genCodeForConverter (org.apache.spark.sql.catalyst.expressions.codegen.CodeGenContext ctx, int index) { throw new RuntimeException(); }
  public  java.lang.String genCode (org.apache.spark.sql.catalyst.expressions.codegen.CodeGenContext ctx, org.apache.spark.sql.catalyst.expressions.codegen.GeneratedExpressionCode ev) { throw new RuntimeException(); }
  public  Object eval (org.apache.spark.sql.catalyst.InternalRow input) { throw new RuntimeException(); }
}
